# CV_Lab2
<!DOCTYPE html>
<html>
<head> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
## Лабораторная 2: Детектирование объектов на изрбражении
</head>
<body>
<h1>Теоретическая база</h1>
<p>Сопоставление шаблонов — это метод поиска и нахождения расположения шаблонного изображения на большом изображении. OpenCV поставляется с функцией cv.matchTemplate() для этой цели. Он просто наводит изображение шаблона на входное изображение (как в 2D-свертке) и сравнивает шаблон и фрагмент входного изображения с изображением шаблона. В OpenCV реализовано несколько методов сравнения. Он возвращает изображение в градациях серого, где каждый пиксель обозначает, насколько окрестности этого пикселя совпадают с шаблоном.</p>
<p>
Если входное изображение имеет размер (WxH), а шаблонное изображение имеет размер (wxh), выходное изображение будет иметь размер (W-w+1, H-h+1). Получив результат, мы можем использовать функцию cv.minMaxLoc(), чтобы найти максимальное/минимальное значение. Возьмем его как верхний левый угол прямоугольника и примим (w,h) как ширину и высоту прямоугольника. Этот прямоугольник является нашейобластью шаблона.
</p>
<p>Следующий алгоритм - ORB. Самое важное в нем то, что он создан в "OpenCV Labs". Этот алгоритм был предложен Итаном Рубли, Винсентом Рабо, Куртом Конолиге и Гэри Р. Брадски в их статье ORB: эффективная альтернатива SIFT или SURF в 2011 году. Как следует из названия, это хорошая альтернатива SIFT и SURF в вычислениях.</p>
<p>
ORB представляет собой сочетание детектора ключевых точек FAST и дескриптора BRIEF со многими модификациями для повышения производительности. Сначала он использует FAST, чтобы найти ключевые точки, а затем применяет угловую меру Харриса, чтобы найти N верхних точек среди них. Он также использует пирамиду для создания многомасштабных функций.</p>
<p>
Мы должны создать объект ORB с помощью функции cv.ORB() или с помощью общего интерфейса feature2d. Он имеет ряд необязательных параметров. Наиболее полезными из них являются nFeatures, которые обозначают максимальное количество сохраняемых функций (по умолчанию 500), scoreType, который указывает, используется ли оценка Харриса или оценка FAST для ранжирования функций (по умолчанию оценка Харриса) и т. д. Другой параметр, WTA_K, определяет количество баллов, которые создают каждый элемент ориентированного дескриптора BRIEF. По умолчанию это два, т.е. выбираются две точки одновременно. В этом случае для сопоставления используется расстояние NORM_HAMMING. Если WTA_K равно 3 или 4, что требует 3 или 4 точек для создания дескриптора BRIEF, то соответствующее расстояние определяется NORM_HAMMING2.</p>
<h1>Описание разработанной системы</h1>
<p>Было реализовано два примитивных детектора объектов на изображении, работающих с помощью поиска эталона на входном изображении.
</p>
<p>В первом файле можно увидеть, что детектирование изображений проводилось как прямой поиск одного изображения на другом (temolate matching). Во втором файле - поиск ключевых точек эталона на входном изображении, с помощью ORB.
</p>
<p>Программа принимает на вход два изображения, эталон и то, на котором будет производиться поиск. На выходе программа строит рамку в виде четыырехгольника в области, где с наибольшей вероятностью находится искомый объект.
</p>
<h1>Вывод результатов</h1>
<h2>Детектирование Сопоставление шаблонов:</h2>
<p><img src="https://github.com/AlexVasilkina/CV_Lab2/blob/main/template1.png?raw=true"></p> 
<p><img src="https://github.com/AlexVasilkina/CV_Lab2/blob/main/template2.png?raw=true"></p> 
<p><img src="https://github.com/AlexVasilkina/CV_Lab2/blob/main/template3.png?raw=true"></p> 
<h2>Детектирование ORB:</h2>
<p><img src="https://github.com/AlexVasilkina/CV_Lab2/blob/main/orb1.png?raw=true"></p> 
<p><img src="https://github.com/AlexVasilkina/CV_Lab2/blob/main/orb2.png?raw=true"></p> 
<p><img src="https://github.com/AlexVasilkina/CV_Lab2/blob/main/orb3.png?raw=true"></p> 
<h1>Выводы по работе</h1>
<p>На мой взгляд, детектор изображений ORB отлично справился со своей задачей с первого раза. На вход поступили достаточно сложные для распознавания изображения и по ключевым точкам шаблонного изображения детектор сработал правильно на всех изображениях, выделив лисичку на кружке как элемент шаблона. Первый детектор сработал хорошо, были проверены все возможные модели, лучше всех со своей задачей справилась модель cv.TM_CCOEFF. Однако нельзя сказать, что этот детектор можно использовать для получения 100% результата. Для того, чтобы алгоритм заработал, мне пришлось 4 раза подбирать изображения разного вида.</p> 
<h1>Использованные источники</h1>
<p>https://docs.opencv.org/4.x/d4/dc6/tutorial_py_template_matching.html</p>
<p>https://docs.opencv.org/3.4/d1/d89/tutorial_py_orb.html</p>
</body>
</html>
